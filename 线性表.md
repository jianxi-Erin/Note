### 线性表(一对一)
#### 1.线性表及其逻辑结构
- 定义:具有相同特性的数据元素的有限序列
- 长度:线性表元素的个数叫线性表长度，没有任何元素的线性表称为空表
- 基本运算:
```c
初始化线性表 InitList(&L）：构造一个空的线性表L。 
销毁线性表 DestroyList(&L）：释放线性表L占用的内存空 间。
判线性表是否为空表 ListEmpty(L）：若L为空表，则返回 真，否则返回假。 
求线性表的长度 ListLength(L) 返回L中元素个数n

输出线性表 DispList(L)：线性表L不为空时，顺序显示L中各结点 的值域。
求线性表L中指定位置的某个数据元素 GetElem(L ，i，&e）：用 e返回L中第 i（1≤i≤n）个元素的值。 
定位查找 LocateElem(L，e)：返回L中第一个值域与e相等的逻 辑位序。若这样的元素不存在，则返回值为0。 
插入一个数据元素ListInsert(&L，i，e)：在L的第i（1≤i≤n） 个元素之前插入新的元素e，L的长度增1。 
删除数据元素 ListDelete(&L，i，&e）：删除L的第i（1≤isn） 个元素，并用e返回其值，L的长度减1。


```
#### 2. 线性表的顺序存储表示和实现
- 顺序表:把线性表所有元素按逻辑顺序依次存储到存储器中一片连续的存储空间中。
- 实现:
```c
//定义顺序表的结构体，命名为SqList
//自定义类型data:线性表元素
//int length:线性表长度
typedef struct ｛
ElemType data[MaxSize];
int length;
} SqList; 


//创建表
void CreateList(SqList * &L，ElemType a[]，int n)  
{  int i=0,k=0;
   L=(SqList *)malloc(sizeof(SqList));
   while (i<n)		//i扫描a中元素
   {  L->data[k]=a[i];
      k++; i++;	//k记录插入到L中的元素个数
   }
   L->length=k;
 }

//初始化
void InitList(SqList *&L)
{  L=(SqList *)malloc(sizeof(SqList));
　　　　//分配存放线性表的顺序表空间
   L->length=0;
}
//销毁
void DestroyList(SqList *&L)
{
    free(L);
}
//判断空表
bool ListEmpty(SqList *L)
{
   return(L->length==0);
}
//获取表长度
int ListLength(SqList *L)
{
     return(L->length);
}
//遍历输出元素
void DispList(SqList *L)
{  int i;
   if (ListEmpty(L)) return;
   for (i=0;i<L->length;i++)
      printf("%c"，L->data[i]);
   printf("\n");
}
//按索引获取元素
bool GetElem(SqList *L，int i，ElemType &e)
{     
   if (i<1 || i>L->length)  return false;
   e=L->data[i-1];
   return true;
}


```

