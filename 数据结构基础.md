## 数据结构(C语言版)
### 一. 数据结构基础知识
- 数据: 能够被输入到计算机中,且能被计算机处理的符号的集合
- 数据元素:是数据的`基本单位`,是数据（集合）中的一个“个体”，在计算机中通常作为一个整体考虑
- 数据项:构成数据元素的不可分割的`最小单位`
- 数据对象:性质相同的数据元素的集合，如整数数据对象是所有整数的集合。 
```c
数据>数据对象>数据元素>数据项
数据对象={数据对象1,数据对象2,..}
```
- 数据结构:数据元素之间相互的关系
 1. 逻辑结构:数据元素之间的逻辑关系
 2. 物理结构/存储结构:数据元素之间关系在计算机内存之间的表示(映像)
 3. 运算与实现:对数据元素施加的操作

-逻辑结构分类:

 分类一:
 1. 线性结构:有且只有一个开始和结束端点,并且所有节点最多只有一个前驱和后继:线性表,栈,队列,串,字符串,数组,广义表等
 2.非线性结构:一个结点可能有多个前驱和后继:树,图等

分类二:

   1. 集合结构:数据元素同属一个集合,没有其他任何关系
   2. 线性结构:数据元素一对一关系
   3. 树形结构:数据元素一对多关系
   4. 图状结构(网状结构):数据元素多对多关系

存储结构分类:

 1. 顺序存储结构:用一组连续的存储单元依次存储数据元素,之间的逻辑关系由存储位置表示:C数组
 2. 链式存储结构:用一组任意的存储单元存储数据元素,逻辑关系用指针表示
 3. 索引存储结构:存储信息的同时建立索引表,通过索引来访问或操作元素
 4. 散列(hash)存储:通过哈希函数计算出元素存储位置
### 二. 算法和分析
- 算法:对特定问题的求解步骤与描述,是指令的有限序列
- 算法描述:自然语言,流程图,伪代码,程序语言
- 程序(数据结构+算法):是对算法的实现
- 算法特性:有穷性,确定性,可行性,输入(0/n),输出(1,n)
- 算法设计要求:正确性,可读性,健壮性,高效性
- 算法分析:
 1. 时间复杂度:算法执行时间T(n)=O(n)
    - 找语句频度(循环次数)最多的语句作
    - 计算并用n表示语句执行次数
    - 保留高次项忽略系数,得到最终结果
    - 用O(最终结果)表示时间复杂度
 2. 空间复杂度:算法所需存储空间的度量

 - 常见算法复杂度例子:
  1. O(1)
   ```c
    int x = 5;
    x = x + 1;  // O(1)

   ```
   2. O(n)
   ```c
    for (int i = 0; i < n; i++) {
    printf("%d\n", i);  // O(n)
    }

   ```
   3. O(log n)
   ```c
    例1.
    while (n > 1) {
    n = n / 2;  // O(log n)
    }
    例2.
    int i=1
    while(i<=n){
        i=i*2
    }
   ```
   4. O(n log n)
   ```c
   int n = 16;
    for (int i = 0; i < n; i++) {
        int x = n;
        while (x > 1) {
        x = x / 2;  // 内层对数操作
        printf("%d\n", x);
        }
    }


   ```

   5. O(n^2)
   ```c
   for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        printf("%d\n", i + j);  // O(n^2)
        }
    }

   ```
   6. O(2^n)
   ```c
   int fib(int n) {
    if (n <= 1) return n;
    return fib(n - 1) + fib(n - 2);  // O(2^n)
    }

   ```
### 三. 线性表(一对一)
#### 1.线性表及其逻辑结构
- 定义:具有相同特性的数据元素的有限序列
- 长度:线性表元素的个数叫线性表长度，没有任何元素的线性表称为空表
- 基本运算:
```c
初始化线性表 InitList(&L）：构造一个空的线性表L。 
销毁线性表 DestroyList(&L）：释放线性表L占用的内存空 间。
判线性表是否为空表 ListEmpty(L）：若L为空表，则返回 真，否则返回假。 
求线性表的长度 ListLength(L) 返回L中元素个数n

输出线性表 DispList(L)：线性表L不为空时，顺序显示L中各结点 的值域。
求线性表L中指定位置的某个数据元素 GetElem(L ，i，&e）：用 e返回L中第 i（1≤i≤n）个元素的值。 
定位查找 LocateElem(L，e)：返回L中第一个值域与e相等的逻 辑位序。若这样的元素不存在，则返回值为0。 
插入一个数据元素ListInsert(&L，i，e)：在L的第i（1≤i≤n） 个元素之前插入新的元素e，L的长度增1。 
删除数据元素 ListDelete(&L，i，&e）：删除L的第i（1≤isn） 个元素，并用e返回其值，L的长度减1。


```
#### 2. 线性表的顺序存储表示和实现
- 顺序表:把线性表所有元素按逻辑顺序依次存储到存储器中一片连续的存储空间中。
- 逻辑位序从1开始，物理位序从0开始
- 实现:
```c
//定义顺序表的结构体，命名为SqList
//自定义类型data:线性表元素
//int length:线性表长度
typedef struct ｛
ElemType data[MaxSize];
int length;
} SqList; 


//创建表
void CreateList(SqList * &L，ElemType a[]，int n)  
{  int i=0,k=0;
   L=(SqList *)malloc(sizeof(SqList));
   while (i<n)		//i扫描a中元素
   {  L->data[k]=a[i];
      k++; i++;	//k记录插入到L中的元素个数
   }
   L->length=k;
 }

//初始化
void InitList(SqList *&L)
{  L=(SqList *)malloc(sizeof(SqList));
　　　　//分配存放线性表的顺序表空间
   L->length=0;
}
//销毁
void DestroyList(SqList *&L)
{
    free(L);
}
//判断空表
bool ListEmpty(SqList *L)
{
   return(L->length==0);
}
//获取表长度
int ListLength(SqList *L)
{
     return(L->length);
}
//遍历输出元素
void DispList(SqList *L)
{  int i;
   if (ListEmpty(L)) return;
   for (i=0;i<L->length;i++)
      printf("%c"，L->data[i]);
   printf("\n");
}
//获取第i个元素，索引为i-1
bool GetElem(SqList *L，int i，ElemType &e)
{     
   if (i<1 || i>L->length)  return false;
   e=L->data[i-1];
   return true;
}
//查找第1个与e相等的元素逻辑位置（索引+1）
int LocateElem(SqList *L，ElemType e)
{  int i=0;
   while (i<L->length && L->data[i]!=e)  
      i++;
   if (i>=L->length)  return 0;
   else  return i+1;
}

//在i插入元素e
bool  ListInsert(SqList *&L，int i，ElemType e)
{  int j;
   if (i<1 || i>L->length+1)
      return false;		//参数错误时返回false
   i--;				//将顺序表逻辑序号转化为物理序号
   for (j=L->length;j>i;j--)	//将data[i..n]元素后移一个位置
	L->data[j]=L->data[j-1];
   L->data[i]=e;		//插入元素e
   L->length++;		//顺序表长度增1
   return true;		//成功插入返回true
}


//删除元素
bool ListDelete(SqList *&L，int i，ElemType &e)
{  int j;
   if (i<1 || i>L->length)	　	//参数错误时返回false
      return false;
   i--;					//将顺序表逻辑序号转化为物理序号
   e=L->data[i];
   for (j=i;j<L->length-1;j++)  	//将data[i..n-1]元素前移
	L->data[j]=L->data[j+1];
   L->length--;			//顺序表长度减1
   return true;			//成功删除返回true
}


```



